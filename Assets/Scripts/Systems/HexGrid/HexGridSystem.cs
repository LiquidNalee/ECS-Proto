using System;using Components.HexGrid;using Unity.Burst;using Unity.Collections;using Unity.Entities;using Unity.Jobs;using Unity.Mathematics;using Unity.Transforms;using UnityEngine;using static Systems.Utils.HexUtils;namespace Systems.HexGrid{    [UpdateInGroup(typeof(InitializationSystemGroup))]    [UpdateBefore(typeof(EndInitializationEntityCommandBufferSystem))]    public class HexGridSystem : SystemBase    {        private NativeQueue<Entity> _adjTilesJobEntryQueue;        private NativeQueue<Entity> _adjTilesJobProcessingQueue;        private NativeQueue<Entity> _adjTilesJobResultQueue;        private EndInitializationEntityCommandBufferSystem _ecbSystem;        private NativeArray<float3> _hexPositions;        private int _ite;        protected override void OnCreate()        {            _ite = 0;            _adjTilesJobEntryQueue = new NativeQueue<Entity>(Allocator.Persistent);            _adjTilesJobProcessingQueue = new NativeQueue<Entity>(Allocator.Persistent);            _adjTilesJobResultQueue = new NativeQueue<Entity>(Allocator.Persistent);            _hexPositions = new NativeArray<float3>(6, Allocator.Persistent);            _hexPositions[(int) HexDirection.Top] = new float3(0f, 0f, -2.1f);            _hexPositions[(int) HexDirection.TopRight] = new float3(-1.81865f, 0f, -1.05f);            _hexPositions[(int) HexDirection.BottomRight] = new float3(-1.81865f, 0f, 1.05f);            _hexPositions[(int) HexDirection.Bottom] = new float3(0f, 0f, 2.1f);            _hexPositions[(int) HexDirection.BottomLeft] = new float3(1.81865f, 0f, 1.05f);            _hexPositions[(int) HexDirection.TopLeft] = new float3(1.81865f, 0f, -1.05f);        }        protected override void OnDestroy()        {            _hexPositions.Dispose();            if (_adjTilesJobEntryQueue.IsCreated) _adjTilesJobEntryQueue.Dispose();            if (_adjTilesJobProcessingQueue.IsCreated) _adjTilesJobProcessingQueue.Dispose();            if (_adjTilesJobResultQueue.IsCreated) _adjTilesJobResultQueue.Dispose();        }        protected override void OnStartRunning()        {            _ecbSystem = World.GetExistingSystem<EndInitializationEntityCommandBufferSystem>();            var jobEntryQueueWriter = _adjTilesJobEntryQueue.AsParallelWriter();            Entities.WithAll<HexTileComponent, AdjacentTileBufferElement>()                    .ForEach((Entity entity) => { jobEntryQueueWriter.Enqueue(entity); })                    .Run();        }        protected override void OnUpdate()        {            if (_ite >= 1) return;            if (_adjTilesJobEntryQueue.IsEmpty() && _adjTilesJobProcessingQueue.IsEmpty() &&                _adjTilesJobResultQueue.IsEmpty())                return;            _ecbSystem.AddJobHandleForProducer(Dependency);            var adjTileBufferLookup = GetBufferFromEntity<AdjacentTileBufferElement>(true);            var hexTileCmpntLookup = GetComponentDataFromEntity<HexTileComponent>(true);            var entryHexTileArray = _adjTilesJobEntryQueue.ToArray(Allocator.TempJob);            _adjTilesJobEntryQueue.Clear();            // var processHexTileArray = _adjTilesJobProcessingQueue.ToArray(Allocator.TempJob);            _adjTilesJobProcessingQueue.Clear();            // var resultHexTileArray = _adjTilesJobResultQueue.ToArray(Allocator.TempJob);            _adjTilesJobResultQueue.Clear();            InstantiateAdjacentTiles(                adjTileBufferLookup,                hexTileCmpntLookup,                entryHexTileArray            );            // SetAdjacentTileValues(adjTileBufferLookup, processHexTileArray);            // TransferQueueContent(resultHexTileArray);        }        private void InstantiateAdjacentTiles(            BufferFromEntity<AdjacentTileBufferElement> adjTileBufferLookup,            ComponentDataFromEntity<HexTileComponent> hexTileCmpntLookup,            NativeArray<Entity> originHexTileArray        )        {            var tileCount = originHexTileArray.Length;            if (tileCount == 0)            {                originHexTileArray.Dispose();                return;            }            var adjTilesJobMap = new NativeMultiHashMap<float3, TileLink>(                tileCount * 6,                Allocator.TempJob            );            var originTilesJobMap =                new NativeMultiHashMap<Entity, TileLink>(tileCount * 6, Allocator.TempJob);            var adjTilesComputeJob = new ComputeAdjacentTilesJob                                     {                                         OriginHexTileArray = originHexTileArray,                                         HexPositions = _hexPositions,                                         AdjacentTileBufferLookup = adjTileBufferLookup,                                         HexTileComponentLookup = hexTileCmpntLookup,                                         MapWriter = adjTilesJobMap.AsParallelWriter()                                     };            var adjTilesComputeJobHandle = adjTilesComputeJob.Schedule(tileCount, 1);            var adjKeyArray = new NativeArray<float3>(tileCount * 6, Allocator.TempJob);            var extractAdjMapKeysJob = new ExtractMapUniqueKeysJob<float3>                                       {                                           MultiHashMap = adjTilesJobMap,                                           KeyArray = adjKeyArray                                       };            var extractAdjMapKeysJobHandle =                extractAdjMapKeysJob.Schedule(adjTilesComputeJobHandle);            var parallelWriter = _ecbSystem.CreateCommandBuffer()                                           .AsParallelWriter();            var adjTilesJob = new InstantiateAdjacentTilesJob                              {                                  AdjTileLinkHashMapKeyArray = adjKeyArray,                                  AdjTileLinkHashMap = adjTilesJobMap,                                  OriginTileCount = tileCount,                                  EcbWriter = parallelWriter,                                  MapWriter = originTilesJobMap.AsParallelWriter()                              };            var adjTilesJobHandle = adjTilesJob.Schedule(                tileCount * 6,                1,                extractAdjMapKeysJobHandle            );            adjTilesJobMap.Dispose(adjTilesJobHandle);            var originKeyArray = new NativeArray<Entity>(tileCount, Allocator.TempJob);            var extractOriMapKeysJob = new ExtractMapUniqueKeysJob<Entity>                                       {                                           MultiHashMap = originTilesJobMap,                                           KeyArray = originKeyArray                                       };            var extractOriMapKeysJobHandle = extractOriMapKeysJob.Schedule(adjTilesJobHandle);            var fixupAdjacentTileRefsJob = new FixupOriginAdjacentTileRefsJob                                           {                                               OriginTileLinkHashMapKeyArray = originKeyArray,                                               OriginTileLinkHashMap = originTilesJobMap,                                               AdjacentTileBufferLookup = adjTileBufferLookup,                                               EcbWriter = parallelWriter                                           };            var fixupAdjacentTileRefsJobHandle = fixupAdjacentTileRefsJob.Schedule(                tileCount,                1,                extractOriMapKeysJobHandle            );            originTilesJobMap.Dispose(fixupAdjacentTileRefsJobHandle);            _ecbSystem.AddJobHandleForProducer(fixupAdjacentTileRefsJobHandle);        }        private void SetAdjacentTileValues(            BufferFromEntity<AdjacentTileBufferElement> adjTileBufferLookup,            NativeArray<Entity> originHexTileArray        )        {            if (originHexTileArray.Length == 0)            {                originHexTileArray.Dispose();                return;            }            var setAdjTileValuesJob = new SetAdjacentTileValuesJob                                      {                                          OriginHexTileArray = originHexTileArray,                                          AdjacentTileBufferLookup = adjTileBufferLookup,                                          EcbWriter = _ecbSystem.CreateCommandBuffer()                                              .AsParallelWriter(),                                          QueueWriter = _adjTilesJobResultQueue                                              .AsParallelWriter()                                      };            var setAdjTileValuesJobHandle =                setAdjTileValuesJob.Schedule(originHexTileArray.Length, 1);            _ecbSystem.AddJobHandleForProducer(setAdjTileValuesJobHandle);        }        private void TransferQueueContent(NativeArray<Entity> hexTileArray)        {            if (hexTileArray.Length == 0)            {                hexTileArray.Dispose();                return;            }            _ite++;            var transferJob = new TransferQueueContentJob<Entity>                              {                                  From = hexTileArray,                                  To = _adjTilesJobEntryQueue.AsParallelWriter()                              };            var transferJobHandle = transferJob.Schedule(hexTileArray.Length, 1);            _ecbSystem.AddJobHandleForProducer(transferJobHandle);        }        [Serializable]        private struct TileLink        {            public int OriginIndex;            public Entity AdjTile;            public Entity Origin;        }        [BurstCompile]        private struct ComputeAdjacentTilesJob : IJobParallelFor        {            [ReadOnly] [DeallocateOnJobCompletion]            public NativeArray<Entity> OriginHexTileArray;            [ReadOnly] public NativeArray<float3> HexPositions;            [ReadOnly] public ComponentDataFromEntity<HexTileComponent> HexTileComponentLookup;            [ReadOnly]            public BufferFromEntity<AdjacentTileBufferElement> AdjacentTileBufferLookup;            [WriteOnly] public NativeMultiHashMap<float3, TileLink>.ParallelWriter MapWriter;            public void Execute(int i)            {                var originHexTile = OriginHexTileArray[i];                var originAdjacentTileBuffer = AdjacentTileBufferLookup[originHexTile];                for (var j = 0; j < 6; ++j)                {                    if (originAdjacentTileBuffer[j] != Entity.Null) return;                    var gridPos = HexTileComponentLookup[originHexTile]                                      .Position + HexPositions[j];                    MapWriter.Add(                        gridPos,                        new TileLink                        {                            Origin = originHexTile, OriginIndex = j, AdjTile = Entity.Null                        }                    );                }            }        }        [BurstCompile]        private struct ExtractMapUniqueKeysJob<TKey> : IJob            where TKey : struct, IEquatable<TKey>        {            [ReadOnly] public NativeMultiHashMap<TKey, TileLink> MultiHashMap;            [WriteOnly] public NativeArray<TKey> KeyArray;            public void Execute()            {                var withDuplicates = MultiHashMap.GetKeyArray(Allocator.Temp);                var uniqueCount = withDuplicates.Unique();                var uniqKeys = withDuplicates.GetSubArray(0, uniqueCount);                KeyArray.CopyFrom(uniqKeys);                withDuplicates.Dispose();            }        }        [BurstCompile]        private struct InstantiateAdjacentTilesJob : IJobParallelFor        {            [ReadOnly] [DeallocateOnJobCompletion]            public NativeArray<float3> AdjTileLinkHashMapKeyArray;            public int OriginTileCount;            [ReadOnly] public NativeMultiHashMap<float3, TileLink> AdjTileLinkHashMap;            [WriteOnly] public EntityCommandBuffer.ParallelWriter EcbWriter;            [WriteOnly] public NativeMultiHashMap<Entity, TileLink>.ParallelWriter MapWriter;            [BurstDiscard]            public void Log(object i, object log) { Debug.Log(i + ": " + log); }            public void Execute(int i)            {                var tileKey = AdjTileLinkHashMapKeyArray[i];                if (!AdjTileLinkHashMap.ContainsKey(tileKey)) return;                var tileLinksEnumerator = AdjTileLinkHashMap.GetValuesForKey(tileKey);                if (!tileLinksEnumerator.MoveNext()) return;                var curTileLink = tileLinksEnumerator.Current;                var tileCmpnt = new HexTileComponent {Position = tileKey};                var tilePos = new Translation {Value = tileKey + new float3(0f, 0.3f, 0f)};                var ecbIndex = curTileLink.Origin.GetHashCode() % OriginTileCount * 6 +                               curTileLink.OriginIndex + 1;                var tile = EcbWriter.Instantiate(ecbIndex, curTileLink.Origin);                Log(ecbIndex, tile);                EcbWriter.SetComponent(ecbIndex, tile, tileCmpnt);                EcbWriter.SetComponent(ecbIndex, tile, tilePos);                EcbWriter.SetBuffer<AdjacentTileBufferElement>(ecbIndex, tile);                var tileBuffer = new NativeArray<AdjacentTileBufferElement>(6, Allocator.Temp);                for (var k = 0; k < 6; ++k)                    tileBuffer[k] = new AdjacentTileBufferElement {Value = Entity.Null};                do                {                    curTileLink = tileLinksEnumerator.Current;                    tileBuffer[curTileLink.OriginIndex] =                        new AdjacentTileBufferElement {Value = curTileLink.Origin};                    curTileLink.AdjTile = tile;                    MapWriter.Add(curTileLink.Origin, curTileLink);                } while (tileLinksEnumerator.MoveNext());                for (var k = 0; k < 6; ++k)                    EcbWriter.AppendToBuffer(ecbIndex, tile, tileBuffer[k]);                tileBuffer.Dispose();            }        }        [BurstCompile]        private struct FixupOriginAdjacentTileRefsJob : IJobParallelFor        {            [ReadOnly] [DeallocateOnJobCompletion]            public NativeArray<Entity> OriginTileLinkHashMapKeyArray;            [ReadOnly] public NativeMultiHashMap<Entity, TileLink> OriginTileLinkHashMap;            [ReadOnly]            public BufferFromEntity<AdjacentTileBufferElement> AdjacentTileBufferLookup;            [WriteOnly] public EntityCommandBuffer.ParallelWriter EcbWriter;            [BurstDiscard]            public void Log(object i, object log) { Debug.Log(i + ": " + log); }            public void Execute(int i)            {                var tileKey = OriginTileLinkHashMapKeyArray[i];                if (!OriginTileLinkHashMap.ContainsKey(tileKey)) return;                var tileLinksEnumerator = OriginTileLinkHashMap.GetValuesForKey(tileKey);                if (!tileLinksEnumerator.MoveNext()) return;                EcbWriter.SetBuffer<AdjacentTileBufferElement>(0, tileKey);                var originAdjacentTileBuffer = AdjacentTileBufferLookup[tileKey];                var tileBuffer = new NativeArray<AdjacentTileBufferElement>(6, Allocator.Temp);                for (var k = 0; k < 6; ++k) tileBuffer[k] = originAdjacentTileBuffer[k];                do                {                    var currTileLink = tileLinksEnumerator.Current;                    tileBuffer[currTileLink.OriginIndex] =                        new AdjacentTileBufferElement {Value = currTileLink.AdjTile};                } while (tileLinksEnumerator.MoveNext());                for (var j = 0; j < 6; ++j)                {                    var ecbIndex = tileKey.GetHashCode() %                                   OriginTileLinkHashMapKeyArray.Length * 6 + j + 1;                    Log(                        ecbIndex,                        tileBuffer[j]                            .Value                    );                    EcbWriter.AppendToBuffer(ecbIndex, tileKey, tileBuffer[j]);                }                tileBuffer.Dispose();            }        }        [BurstCompile]        private struct SetAdjacentTileValuesJob : IJobParallelFor        {            [ReadOnly] [DeallocateOnJobCompletion]            public NativeArray<Entity> OriginHexTileArray;            [ReadOnly]            public BufferFromEntity<AdjacentTileBufferElement> AdjacentTileBufferLookup;            [WriteOnly] public EntityCommandBuffer.ParallelWriter EcbWriter;            [WriteOnly] public NativeQueue<Entity>.ParallelWriter QueueWriter;            public void Execute(int i)            {                var originHexTile = OriginHexTileArray[i];                var originAdjacentTileBuffer = AdjacentTileBufferLookup[originHexTile];                for (var j = 0; j < 6; ++j)                {                    var adjTile = originAdjacentTileBuffer[j];                    if (adjTile == Entity.Null) continue;                    var adjTileAdjacentTileBuffer = AdjacentTileBufferLookup[adjTile];                    EcbWriter.SetBuffer<AdjacentTileBufferElement>(i, adjTile);                    for (var k = 0; k < 6; ++k)                        if (k == (j + 4) % 6)                            EcbWriter.AppendToBuffer(                                i,                                adjTile,                                new AdjacentTileBufferElement                                {                                    Value = originAdjacentTileBuffer[(j + 5) % 6]                                }                            );                        else if (k == (j + 2) % 6)                            EcbWriter.AppendToBuffer(                                i,                                adjTile,                                new AdjacentTileBufferElement                                {                                    Value = originAdjacentTileBuffer[(j + 1) % 6]                                }                            );                        else                            EcbWriter.AppendToBuffer(i, adjTile, adjTileAdjacentTileBuffer[k]);                    QueueWriter.Enqueue(adjTile);                }            }        }        [BurstCompile]        private struct TransferQueueContentJob<T> : IJobParallelFor where T : struct        {            [ReadOnly] [DeallocateOnJobCompletion] public NativeArray<T> From;            [WriteOnly] public NativeQueue<T>.ParallelWriter To;            public void Execute(int i) { To.Enqueue(From[i]); }        }    }}